
/**
 * Interpolate Path
 * Given two selected paths and a number of steps to perform, this plugin will
 * generate intermediate paths s.t. the first path transforms into the second
 * one step by step.
 *
 * This is my first Sketch Plugin and the Sketch API is a huge undocumented
 * mess. It might take a while until this plugin works properly... right now
 * it kind of works sometimes, but it's still full of bugs.
 *
 * @author Martin Matysiak (kaktus621@gmail.com)
 */


/**
 * Interpolates a single point of a path. Makes sure that curvePoints are
 * correctly combined if either {a} or {b} is an uncurved point.
 */
function interpolatePoint(a, b, interpolator) {
  return {
    x: interpolator(a.x, b.x),
    y: interpolator(a.y, b.y)
  };
}


/**
 * Performs the interpolation of {a} and {b} using interpolation function
 * {interpolator} and stores the interpolated points in {path}.
 */
function interpolatePaths(path, a, b, interpolator) {
  for (var i = 0; i < path.path().points().length(); i++) {
    var point = path.path().points()[i];
    var aP = a.path().points()[i];
    var bP = b.path().points()[i];

    var curveFrom = interpolatePoint(
        aP.curveFrom() || aP.point(),
        bP.curveFrom() || bP.point(),
        interpolator);

    var p = interpolatePoint(aP.point(), bP.point(), interpolator);

    var curveTo = interpolatePoint(
        aP.curveTo() || aP.point(),
        bP.curveTo() || bP.point(),
        interpolator);

    point.movePointTo(p);
    point.setCurveFrom(curveFrom);
    point.setCurveTo(curveTo);

  }
}


log("%%%%%%%%%%%%%% START %%%%%%%%%%%%%%");
if (selection.length() != 2) {
  log("Invalid number of objects selected");
}

var start = selection[0];//.layers()[0];
var target = selection[1];//.layers()[0];

if (start.layers()[0].path().points().length() !=
    target.layers()[0].path().points().length()) {
  log("Paths must have same number of points");
}

log(start.frame());
log(target.frame());

var steps = 10; // TODO: prompt user for that
var stepSize = 1.0 / (steps + 1);

for (var i = 1; i <= steps; i++) {
  // duplicate start path
  var clone = start.duplicate();
  var lambda = i * stepSize;
  var interpolator = function(a, b) {
    return lambda * a + (1 - lambda) * b;
  }

  // Placeholder because I'm lazy.
  var c, s, t;

  // Inside the frame the path is using relative coordinates.
  // To make sure the path is still position correctly with respect to the
  // document, we will have to reposition and resize the bounding box of the
  // path accordingly.
  c = clone.frame();
  s = start.frame();
  t = target.frame();

  c.setX(interpolator(s.x(), t.x()));
  c.setY(interpolator(s.y(), t.y()));
  c.setWidth(interpolator(s.width(), t.width()));
  c.setHeight(interpolator(s.height(), t.height()));

  // Interpolate path-level properties
  c = clone.style();
  s = start.style();
  t = target.style();

  c.contextSettings().setOpacity(interpolator(s.contextSettings().opacity(),
      t.contextSettings().opacity()));


  // Modify single points of the path according to the interpolator
  interpolatePaths(clone.layers()[0],
      start.layers()[0],
      target.layers()[0],
      interpolator);
}

